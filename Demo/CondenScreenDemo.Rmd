---
title: "CondenScreen R Script"
output: html_notebook
---

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
#PACKAGES
#------------------------------------------------------------------------------
# Packages are automatically installed if missing to ensure reproducibility

required_packages <- c(
  "tidyverse",
  "knitr",
  "DBI",
  "ggpval",
  "openxlsx",
  "EnvStats",
  "ggpubr",
  "psych",
  "plotrix",
  "BSDA",
  "ggrepel",
  "data.table",
  "progress",
  "shiny",
  "plotly",
  "htmltools",
  "sass",
  "rlang"
)

installed <- rownames(installed.packages())

for (pkg in required_packages) {
  if (!pkg %in% installed) {
    message("Installing package: ", pkg)
    install.packages(pkg, dependencies = TRUE)
  }
  library(pkg, character.only = TRUE)
}
 
```

```{r}
# CondenScreen GUI 
#------------------------------------------------------------------------------
  
# Function to generate well coordinates
generate_well_coordinates <- function(rows, cols) {
  expand.grid(Row = LETTERS[1:rows], Col = 1:cols) %>%
    mutate(Well = paste0(Row, sprintf("%02d", Col)))
}

# Define UI
ui <- fluidPage(
  titlePanel("CondenScreen Well Selection:"),
  sidebarLayout(
    sidebarPanel(
      selectInput("plate_type", "Select Plate Type:", 
                  choices = c("6-well" = "2x3", "12-well" = "3x4", "24-well" = "4x6", 
                              "96-well" = "8x12", "384-well" = "16x24")),
      
      radioButtons("condition", "Select Condition:", 
                   choices = c("Positive Control", "Negative Control", "Test Condition")),
      
      textInput("pos_control_name", "Positive Control Name:", value = "Positive Ctrl"),
      textInput("neg_control_name", "Negative Control Name:", value = "Negative Ctrl"),
      
      actionButton("signal_toggle", "Signal: OFF", style = "width: 100%"),
      actionButton("clear", "Clear Selections"),
      hr(),
      
      # Interactive save directory selection
      strong("Save Directory:"),
      div(style = "display: flex; margin-bottom: 10px;",
          textInput("save_dir", NULL, value = paste0(getwd(), "/"), width = "100%")),
  
      
      textInput("save_filename", "Save File Name: (end with .csv; Final analysis will be in YOURFILENAME_results.csv)", value = "well_selection.csv"),
      
      # Interactive input directory selection
      strong("Input Directory:"),
      div(style = "display: flex; margin-bottom: 10px;",
          textInput("input_dir", NULL, value = paste0(getwd(), "/"), width = "100%"),
          actionButton("parent_input_dir", "â†‘", style = "margin-left: 5px;"),
          actionButton("reset_input_dir", "Reset", style = "margin-left: 5px;")
      ),
      
      hr(),
      
      downloadButton("download", "Download Selection"),
      
      # Show subdirectories in the current save directory
      # strong("Available subdirectories:"),
      # uiOutput("subdirectories")
    ),
    
    mainPanel(
      plotlyOutput("plate_plot"),
      tableOutput("selected_wells")
    )
  )
)

# Define server logic
server <- function(input, output, session) {
  
  # Reactive values for directories
  save_dir <- reactiveVal(getwd())
  input_dir <- reactiveVal(file.path(getwd(), "data"))
  
  # Update save_dir when text input changes
  observeEvent(input$save_dir, {
    if (dir.exists(input$save_dir)) {
      save_dir(input$save_dir)
    }
  })
  
  # Update input_dir when text input changes
  observeEvent(input$input_dir, {
    if (dir.exists(input$input_dir)) {
      input_dir(input$input_dir)
    }
  })
  
  # Go to parent directory (save)
  observeEvent(input$parent_dir, {
    current <- save_dir()
    parent <- dirname(current)
    save_dir(parent)
    updateTextInput(session, "save_dir", value = parent)
  })
  
  # Go to home directory (save)
  observeEvent(input$home_dir, {
    home <- path.expand("~")
    save_dir(home)
    updateTextInput(session, "save_dir", value = home)
  })
  
  # Go to parent directory (input)
  observeEvent(input$parent_input_dir, {
    current <- input_dir()
    parent <- dirname(current)
    input_dir(parent)
    updateTextInput(session, "input_dir", value = parent)
  })
  
  # Reset input directory
  observeEvent(input$reset_input_dir, {
    default <- file.path(getwd(), "data")
    input_dir(default)
    updateTextInput(session, "input_dir", value = default)
  })
  
  # List subdirectories for selection
  output$subdirectories <- renderUI({
    current_dir <- save_dir()
    if (!dir.exists(current_dir)) return(NULL)
    
    # Get all subdirectories
    dirs <- list.dirs(current_dir, full.names = FALSE, recursive = FALSE)
    # Remove hidden directories (starting with .)
    dirs <- dirs[!grepl("^\\.", dirs)]
    
    if (length(dirs) == 0) {
      return(p("No subdirectories found"))
    }
    
    # Create buttons for each subdirectory
    tagList(
      div(style = "max-height: 150px; overflow-y: auto;",
          lapply(dirs, function(dir) {
            actionButton(
              inputId = paste0("dir_", gsub("[^a-zA-Z0-9]", "_", dir)),
              label = dir,
              style = "margin: 2px; display: block; width: 100%; text-align: left;",
              onclick = sprintf(
                "Shiny.setInputValue('select_subdir', '%s');",
                file.path(current_dir, dir)
              )
            )
          })
      )
    )
  })
  
  # Handle subdirectory selection
  observeEvent(input$select_subdir, {
    if (dir.exists(input$select_subdir)) {
      save_dir(input$select_subdir)
      updateTextInput(session, "save_dir", value = input$select_subdir)
    }
  })
  
  # Reactive plate dimensions
  plate_dims <- reactive({
    dims <- strsplit(input$plate_type, "x")[[1]]
    list(rows = as.numeric(dims[1]), cols = as.numeric(dims[2]))
  })
  
  # Reactive well coordinates
  well_data <- reactiveVal(data.frame(Well = character(), Condition = character()))
  
  # Global dataframe for storing selected wells
  selected_wells_global <- reactiveVal(data.frame(Well = character(), Condition = character()))
  
  # Generate plate layout
  observeEvent(input$plate_type, {
    dims <- plate_dims()
    df <- generate_well_coordinates(dims$rows, dims$cols)
    df$Condition <- "None"
    isolate(well_data(df))
  })
  
  # Initialize the plate layout when the app starts
  observe({
    # This will trigger once when the app starts
    if(nrow(well_data()) == 0) {
      dims <- plate_dims()
      df <- generate_well_coordinates(dims$rows, dims$cols)
      df$Condition <- "None"
      well_data(df)
    }
  })
  
  # Signal ON/OFF toggle
  signal_status <- reactiveVal(FALSE)
  
  observeEvent(input$signal_toggle, {
    signal_status(!signal_status())  # Toggle state
    updateActionButton(session, "signal_toggle", 
                       label = ifelse(signal_status(), "Signal: ON", "Signal: OFF"))
  })
  
  # Render plate plot
  output$plate_plot <- renderPlotly({
    df <- well_data()
    
    plot_ly(df,
            x = ~factor(Col, levels = unique(Col)),
            y = ~factor(Row, levels = rev(unique(Row))),
            type = "scatter",
            mode = "markers",
            marker = list(size = 15, color = ~case_when(
              Condition == "Positive Control" ~ "green",
              Condition == "Negative Control" ~ "red",
              Condition == "Test Condition" ~ "black",
              TRUE ~ "gray"
            )),
            source = "plateplot") %>%
      layout(
        xaxis = list(title = "Column", tickmode = "array",
                     tickvals = unique(df$Col), ticktext = unique(df$Col)),
        yaxis = list(title = "Row", tickmode = "array",
                     tickvals = unique(df$Row), ticktext = rev(unique(df$Row)) ),
        showlegend = FALSE,
        dragmode = "select"
      )
  })
  
  # Handle multiple well selection
  observeEvent(event_data("plotly_selected", source = "plateplot"), {
    selected_data <- event_data("plotly_selected", source = "plateplot")
    if (is.null(selected_data)) return()
    
    df <- well_data()
    
    for(i in 1:nrow(selected_data)) {
      row <- as.character(selected_data$y[i])
      col <- as.numeric(selected_data$x[i])
      matching_wells <- df$Well[df$Row == row & df$Col == col]
      df$Condition[df$Well %in% matching_wells] <- input$condition
    }
    
    well_data(df)
    
    # Update global dataframe
    selected_wells_global(df %>% filter(Condition != "None"))
  })
  
  # Handle single click selection
    observeEvent(event_data("plotly_click", source = "plateplot"), {
    click_data <- event_data("plotly_click", source = "plateplot")
    if (is.null(click_data)) return()
    
    df <- well_data()
    well <- df$Well[df$Row == as.character(click_data$y) & df$Col == as.numeric(click_data$x)]
    df$Condition[df$Well == well] <- input$condition
    well_data(df)

    # Update global dataframe
    selected_wells_global(df %>% filter(Condition != "None"))
  })
    
  # Display selected wells
  output$selected_wells <- renderTable({
    well_data() %>% 
      mutate(Condition = case_when(
        Condition == "Positive Control" ~ input$pos_control_name,
        Condition == "Negative Control" ~ input$neg_control_name,
        Condition == "None" ~ NA,

        TRUE ~ Condition
      ))
  })
  
  # Download selected wells
  output$download <- downloadHandler(
  filename = function() {
    input$save_filename
  },
  content = function(file) {
    df <- well_data() %>%
      mutate(Condition = case_when(
        Condition == "Positive Control" ~ input$pos_control_name,
        Condition == "Negative Control" ~ input$neg_control_name,
        Condition == "None" ~ NA,
        TRUE ~ Condition
      ))
    
    # Create a dataframe for the settings
    settings_df <- data.frame(
      SaveDirectory = save_dir(),
      InputDirectory = input_dir(),
      SignalStatus = ifelse(signal_status(), "ON", "OFF"),
      PositiveControlName = input$pos_control_name,
      NegativeControlName = input$neg_control_name,
      stringsAsFactors = FALSE
    )
    
    # Combine settings with well data
    final_df <- cbind(settings_df, df)
    
    # Create the target directory if it doesn't exist
    target_dir <- save_dir()
    if (!dir.exists(target_dir)) {
      dir.create(target_dir, recursive = TRUE, showWarnings = FALSE)
    }
    
    # Write to the specified path
    write.csv(final_df, file, row.names = FALSE) 
  }
)
  # Clear selections
  observeEvent(input$clear, {
    df <- well_data()
    df$Condition <- "None"
    well_data(df)
    
    # Clear global dataframe
    selected_wells_global(data.frame(Well = character(), Condition = character()))
  })
  
  # Clean up when session ends
  session$onSessionEnded(function() {
    stopApp()
  })
}

# Run the application 
shinyApp(ui = ui, server = server)
```


```{r}
#EDIT: Add path to recently saved .csv file:
#############################################################  
#Make sure all pathways use foward slash (/)!
save_Location <- "/home/userX/pathsource/"
#############################################################

dfSelection <-  fread(paste0(save_Location, "well_selection.csv"))

#Add trailing slash, if necessary:
add_trailing_slash <- function(filePath) {
  # Replace backslashes and double slashes with forward slashes
  filePath <- gsub("\\\\+", "/", filePath)  # replaces \ and \\ with /
  filePath <- gsub("/+", "/", filePath)     # collapses multiple / into a single /

  # Ensure exactly one trailing slash
  filePath <- sub("/?$", "/", filePath)

  return(filePath)
}

image_Save_Location <- add_trailing_slash(dfSelection$SaveDirectory[1])
file_Location <- add_trailing_slash(dfSelection$InputDirectory[1])
assayType <- dfSelection$SignalStatus[1]
pos_Ctrl <- dfSelection$PositiveControlName[1]
neg_Ctrl <- dfSelection$NegativeControlName[1]
trial_Name <- paste("Plate", sep = " ")

#Edit: Change string parsing to match the specific naming convention you used while naming the CellProfiler output
#UNLESS CHANGED FILENAME PATTERNS IN CELLPROFILER, LEAVE AS IS:
#Change recursive = TRUE to FALSE if you don't wish to search through all sub-directories of your current directory
#############################################################
file_paths <- dir(file_Location, pattern = "*.FociQuant", full.names = TRUE, recursive = TRUE)
#############################################################

# Save file paths to disk so each batch can access them
saveRDS(file_paths, paste0(file_Location, "file_paths.rds"))

# Define batch size
batch_size <- 20
total_files <- length(file_paths)
total_batches <- ceiling(total_files / batch_size)

# Launch each batch as a separate R process
for (i in 1:total_batches) {
  start_idx <- (i-1) * batch_size + 1
  end_idx <- min(i * batch_size, total_files)
  
  cat("Launching batch", i, "of", total_batches, "\n")
  
  # Build command to run the batch processor as a separate R process
  cmd <- paste0(
    "Rscript ",
    paste0(file_Location, "process_batch.R "),
    start_idx, " ", 
    end_idx, " ", 
    i, " ",
    #Repeated, once for the cell .xlsx and the individual nuclear foci .xlsx 
    paste0(file_Location, "file_paths.rds "),
    #paste0(file_Location, "file_paths2.rds "),
    file_Location
  )
  
  # Run the command
  system(cmd)
  gc()
 }
 
# After all batches are done, combine if needed
cat("All batches completed. Combining results...\n")

# List all batch files
batch_files <- list.files(file_Location, 
                         pattern = "^batch_\\d+\\.csv$", 
                         full.names = TRUE)
# Combine all batches into a final result
combined_data <- rbindlist(lapply(batch_files, fread))
fwrite(combined_data, paste0(file_Location, "final_combined_result.csv"))

cat("Processing complete!\n")


# Check if the file exists
path_to_batchScript <- paste0(file_Location, "process_batch.R")

if (file.exists(path_to_batchScript)) {
  cat("The batch script exists. Success!\n")
} else {
  cat("The batch script file does not exist. Try downloading directly into your selected file_Location \n")
}
```


```{r}
# STRING EXTRACTION FOR WELL/PLATE NAMING CONVENTIONS 

# Vectorized version
extract_info_vectorized <- function(combinedDF) {
  
  # Define patterns
#================================================================
  pattern_filename <- "([A-Za-z0-9]+)_([A-Za-z0-9]+)_s(\\d+)_w\\d+"
  pattern_pathname <- "\\d{8}-([A-Za-z0-9]+)_Plate_\\d+"
#================================================================
  # Extract all matches at once using vectorized operations
  matches <- str_match(combinedDF$FileName_GFP, pattern_filename)
  
  # Initialize result tibble with extracted values
  result <- tibble(
    plate_Num = matches[, 2],
    Well_Num = matches[, 3],
    Image_Num = matches[, 4]
  )
  
  return(result)
}


# Apply the vectorized function directly to the dataframe
extractedInfo <- extract_info_vectorized(combined_data)

combined_data[, c("plate_Num", "Well_Num", "Imagecopy_Num") := extractedInfo]
combined_data[combined_data$Well == "B12",]


combined_Df <- combined_data

#comment out unless explicitly needed (doubtful)
combined_Df$plate_Num[combined_Df$plate_Num == "READ"] <- "A19840"
 

```


```{r}
# INDIVIDUAL CONDITION/CONTROL STATISTICS 
#------------------------------------------------------------------------------
# *OPTIONAL* [PRIMARLY FOR SIGNAL ON SCREENS] Filter out bottom 75% (to control for a transfection efficiency of 1:4)
#Filter conditions that leave < 5 cells/image (too much variance for meaningful interpretation)
combined_Df <- combined_Df %>%
  
  group_by(plate_Num, Well_Num, ImageNumber) %>%
  
  arrange(Children_GFP_foci_Count, .by_group = TRUE) %>%
  
  #---------------------------------------
  #COMMENT OUT UNLESS YOU WANT TO TAKE ONLY THE TOP 25% OF CELLS TO ACCOUNT FOR TRANSFECTION EFFICIENCY!!!
  # mutate(nlen = ceiling(n() * 0.75)) %>%
  # filter(row_number() > nlen) %>%
  #--------------------------------------

  filter(n() > 5) %>%
  ungroup() %>%
  
  group_by(plate_Num, Well_Num, Imagecopy_Num) %>%
  
  mutate(
    Nuclei_Number = n(),
    mean_Nuc_Foci = mean(Children_GFP_foci_Count, na.rm = TRUE)
  ) %>%
  
  ungroup()

#Combine with assigned conditions:
colnames(dfSelection)[8] <- "Well_Num"
combined_Df <- merge(combined_Df, dfSelection[, c('SignalStatus', 'Condition', 'Well_Num')], by = "Well_Num")

combined_Df <- combined_Df %>% 
  mutate(Condition = ifelse(Condition == "Test Condition", Well_Num, Condition)) %>%
  filter(complete.cases(.))

combined_Df <- combined_Df %>%
  group_by(plate_Num, Well_Num) %>%
  
  # This prevents NC wells from being dropped
  mutate(
    summary_condition = if_else(
      SignalStatus == "ON",                               # only filter for ON wells
      mean_Nuc_Foci < max(mean_Nuc_Foci, na.rm = TRUE),# drop the single top image
      TRUE                                              # keep everything for OFF wells
    )
  ) %>%
  
  filter(summary_condition) %>%
  
  summarise(
    Nuclei_Number       = mean(Nuclei_Number),
    Avg_Foci            = mean(mean_Nuc_Foci),
    Nuclei_Area         = mean(AreaShape_Area),
    Nuclear_FormFactor  = mean(AreaShape_FormFactor),
    AssayType           = first(SignalStatus),
    Condition           = first(Condition)
  )


#Determine control statistics:
pos_Ctrl_DF <- combined_Df %>% group_by(plate_Num) %>%
  filter( Condition == pos_Ctrl) %>%
  summarize(mean_Pos_SD = sd(Avg_Foci), mean_Pos_Foci = mean(Avg_Foci), cv_Pos = cv(Avg_Foci)*100, Nuclei_Pos_Area = mean(Nuclei_Area), Nuclear_Pos_FormFactor = mean(Nuclear_FormFactor))

neg_Ctrl_DF <- combined_Df %>% group_by(plate_Num) %>%
  filter( Condition == neg_Ctrl) %>%
  summarize(mean_Neg_SD = sd(Avg_Foci), mean_Neg_Foci = mean(Avg_Foci), cv_Neg= cv(Avg_Foci)*100, Nuclei_Neg_Area = mean(Nuclei_Area), Nuclear_NegFormFactor = mean(Nuclear_FormFactor))

plate_Summary <- merge(pos_Ctrl_DF, neg_Ctrl_DF)

ZPrime_Score <- plate_Summary %>% summarize(ZScore = round(1 - (3*(mean_Pos_SD + mean_Neg_SD) / abs(mean_Pos_Foci - mean_Neg_Foci)), 2))

SB_Plate <- plate_Summary %>% group_by(plate_Num) %>%
  mutate(
    SB_Plate = ifelse(
      unique(assayType) == "OFF", 
      mean_Neg_Foci / mean_Pos_Foci, 
      mean_Pos_Foci / mean_Neg_Foci
    )
  )


#EXPORT PLATE SUMMARY:
plate_Summary$ZPrime_Score <- ZPrime_Score[[1]]
plate_Summary$SB_Plate <- SB_Plate[[ncol(SB_Plate)]]

p_ctrls <- combined_Df %>% filter( Condition == pos_Ctrl) %>%
  group_by(plate_Num) %>%
     summarise(Control = paste0(pos_Ctrl), across(c( Nuclei_Number, Avg_Foci, Nuclei_Area, Nuclear_FormFactor), mean, na.rm = TRUE), Condition = pos_Ctrl)


n_ctrls <- combined_Df %>% filter( Condition == neg_Ctrl) %>% 
  group_by(plate_Num) %>%
     summarise(Control = paste0(neg_Ctrl), across(c(Nuclei_Number, Avg_Foci, Nuclei_Area, Nuclear_FormFactor), mean, na.rm = TRUE), Condition = neg_Ctrl)

#Export controls summary:
ctrls <- rbind(p_ctrls, n_ctrls)

#Combined main dataframe: 
combined_Df <- merge(combined_Df, plate_Summary[, c("plate_Num", "ZPrime_Score")], by = "plate_Num" )


 
```


```{r}
# NORMALIZED EFFECTS & CYTOTOXICITY AND MORPHOLOGY ANALYSIS
#------------------------------------------------------------------------------

#Creates a temp dataframe to not write over original
 temp_stats_Df<- combined_Df %>%
  # Remove controls
  filter(Condition == Well_Num) %>%
  
  # Group by plate number
  group_by(plate_Num) %>%
  
  # Calculate percent change relative to plate
  mutate(
    PercentChange = ifelse(
      `AssayType` == "OFF",
      ((mean(Avg_Foci) - Avg_Foci) / mean(Avg_Foci)) * 100,
      ((Avg_Foci - mean(Avg_Foci)) / mean(Avg_Foci)) * 100
    ),
    
    # Calculate the mean and standard deviation of each plate (based on PercentChange)
    mean_percentEffect = mean(PercentChange),
    SD_percentEffect = sd(PercentChange),
  
    # Calculate Z-scores for test conditions specific to each plate
    ZScore = (PercentChange - mean_percentEffect) / SD_percentEffect,
  
    # Calculate normalized differences for nuclear area, form factor, and cell count
    NuclearAreaDiff = (Nuclei_Area - mean(Nuclei_Area)) / mean(Nuclei_Area) * 100,
    NuclearFormFactorDiff = (Nuclear_FormFactor - mean(Nuclear_FormFactor)) / mean(Nuclear_FormFactor) * 100,
    CellCountDiff = (Nuclei_Number - mean(Nuclei_Number)) / mean(Nuclei_Number) * 100
  )

#Remove any duplicated columns up till now 
combined_Df <- combined_Df[, !duplicated(as.list(combined_Df))]

#Ceullular Health Function (as function of cell density, nuclear area, and nuclear formfactor/morphological differences)
temp_stats_Df$Viability <- temp_stats_Df %>% group_by(plate_Num, Well_Num) %>%
  
  summarize(Viability =
    CellCountDiff + ((100 + CellCountDiff) / 100) * mean(NuclearAreaDiff, NuclearFormFactorDiff)) %>% 
     pull(Viability)


combined_DfTemp <- combined_Df
```



```{r}

#------------------------------------------------------------------------------
# B-SCORE CALCULATION (CONTROLS FOR POSITIONAL EFFECTS)
#------------------------------------------------------------------------------
# Convert to matrix format for median polish algorithm
# B-score normalizes for row/column effects in plates
# BScore_func <- function(df) {

BScore_func <- function(df) {
  
  temp_df <- df 

  # Extract well coordinates (e.g., A01, B02, etc.)
  letters = substr(temp_df$Well_Num, 1, 1)  # Row (A, B, C...)
  numbers = as.numeric(substr(temp_df$Well_Num, 2, 
                               nchar(as.character(temp_df$Well_Num))))  # Column (1, 2, 3...)
  
  # Get unique row and column values
  unique_letters = unique(letters)
  unique_numbers = unique(numbers)
  
  # Create empty matrix with proper dimensions
  mtx = matrix(NA, 
                nrow = length(unique_letters), 
                ncol = length(unique_numbers), 
                dimnames = list(unique_letters, unique_numbers))
  
  # Fill matrix with normalized effect values
  for (i in 1:nrow(temp_df)) {
    row_index <- match(letters[i], rownames(mtx))
    col_index <- match(numbers[i], colnames(mtx))
    mtx[row_index, col_index] <- as.numeric(temp_df$PercentChange[i])
  }
  
  # See: https://academic.oup.com/bioinformatics/article/28/13/1775/235775
  # and: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4653387/
  
  #Replaces NAs that would crash the code with median values of plate, if applicable.
  bScore <- tryCatch({
  mtx_Polish <- medpolish(mtx)
  residuals <- mtx_Polish$residuals
  
  # Calculate median absolute deviation for scaling
  MAD <- mad(residuals, constant = 1)
  
  # Calculate B-score = residuals / MAD
  residuals / MAD
   
}, error = function(e) {
  
  # Fallback if medpolish fails
  num_NA <- length(mtx[is.na(mtx)])
  message(paste0("B-score calculation failed for this plate, replacing ", num_NA, " NA's with plate median... Trying again."))
  mtx_mean <- mean(mtx, na.rm = TRUE)
  mtx[is.na(mtx)] <- mtx_mean
  
  mtx_Polish <- medpolish(mtx)
  residuals <- mtx_Polish$residuals
  
  # Calculate median absolute deviation for scaling
  MAD <- mad(residuals, constant = 1)
  
  # Calculate B-score = residuals / MAD
  residuals / MAD
   
}) 
  
  # Convert matrix back to dataframe
  row_names <- rownames(bScore)
  col_names <- colnames(bScore)
  BScoreDf <- data.frame(Well_Condition = character(), BScore = numeric())
  
  # Process each element in the matrix
  for (i in 1:nrow(bScore)) {
    for (j in 1:ncol(bScore)) {
      if (!is.na(bScore[i, j])) {
        # Format well ID with leading zeros for column numbers (A01, A02...)
        Well_Condition <- paste0(row_names[i], sprintf("%02d", as.numeric(col_names[j])))
        # Add to dataframe
        BScoreDf <- rbind(BScoreDf, 
                          data.frame(Well_Num = Well_Condition, 
                                     BScore = bScore[i, j]))
      }
    }
  }
  
  
  # Calculate B-score statistics
  avg_B <- mean(BScoreDf$BScore)
  SD_B <- sd(BScoreDf$BScore)
  
  # Calculate B-score Z-scores for hit identification
  BScoreDf$BZ_Score <- (BScoreDf$BScore - avg_B) / SD_B
  
  original_wells <- unique(temp_df$Well_Num)
  BScoreDf <- BScoreDf %>% filter(Well_Num %in% original_wells)
}



#Only use BZ-score when assay is Signal-off [due to higher noise and extra normalization for plate-to-plate variation]
if(assayType == "OFF"){
  temp_stats_Df$BScore <- temp_stats_Df %>% 
  group_by(plate_Num) %>% 
  nest() %>%
  mutate(bscores = map(data, BScore_func)) %>%
  unnest(bscores) %>%
   pull(BScore)
 
 
 temp_stats_Df$BZScore <- temp_stats_Df %>% 
  group_by(plate_Num) %>% 
  nest() %>%
  mutate(bscores = map(data, BScore_func)) %>%
  unnest(bscores) %>%
   pull(BZ_Score)
  
}

combined_Df <- merge(combined_Df, temp_stats_Df, all = TRUE)
```




```{r}
# EXPORT PLATE FIGURES (OPTIONAL, CAN COMMENT OUT) 


#### NOTE: IF A WELL IS BLANK, IT LIKELY MEANS VIABILITY WAS TOO LOW FOR ROBUST STATISTICS
#------------------------------------------------------------------------------
library(gridExtra)

# Define path
sub_dir <- paste0(file_Location,"Plate_Figures/") 

# Create subdirectory
if (!dir.exists(sub_dir)) {
  dir.create(sub_dir, recursive = TRUE)
  print("Subdirectory created successfully!")
} else {
  print("Subdirectory already exists.")
}


for (plate in seq_len(length(unique(combined_Df$plate_Num)))){
  plate_List <- unique(combined_Df$plate_Num)
  sub_df <- subset(combined_Df, plate_Num == plate_List[plate])

   nuc_plate <- plate_plot(
    data = sub_df,
    position = Well_Num,
    value = Avg_Foci,
    plate_size = 384,
    label = round(Avg_Foci, 0),
    title = paste(plate_List[plate], ", Avg. Foci/Condition:", sep = ""),
    title_size = 14,
    label_size = 1.6,
    colour = c("#FF0000", "#006600", "#006600", "#00CC00", "#00FF00")
   
  )

    
    cell_plate <- plate_plot(
    data = sub_df,
    position = Well_Num,
    value = Nuclei_Number,
    plate_size = 384,
    label = round(Nuclei_Number),
    title = paste(plate_List[plate], ", Avg. Cell Count/Condition:", sep = ""),
    title_size = 14,
    label_size = 1.6,
    colour = c("#FF0000", "#006600", "#006600", "#00CC00", "#00FF00")
  )
    
   combined_plot <- grid.arrange(nuc_plate, cell_plate, ncol = 1)

  ggsave(filename = paste0(sub_dir, paste(plate_List[plate], "WTScreen_Figure.png")), plot = combined_plot, width = 8, height = 8)

}
```

```{r}
# ORGANIZE AND EXPORT RANKED DATA
#------------------------------------------------------------------------------
p_ctrls <- combined_Df %>% filter( Condition == pos_Ctrl) %>%
  group_by(plate_Num) %>%
     summarise(Control = paste0(pos_Ctrl), across(c( Nuclei_Number, Avg_Foci, Nuclei_Area, Nuclear_FormFactor), mean, na.rm = TRUE))


n_ctrls <- combined_Df %>% filter( Condition == neg_Ctrl) %>% 
  group_by(plate_Num) %>%
     summarise(Control = paste0(neg_Ctrl), across(c(Nuclei_Number, Avg_Foci, Nuclei_Area, Nuclear_FormFactor), mean, na.rm = TRUE))

#Export to Control page
ctrls <- rbind(p_ctrls, n_ctrls)
ctrls <- unique(ctrls)

#Need to change signal-to-background -- currently showing plate number...
plate_Summary <- plate_Summary %>% 
  mutate(across(where(is.numeric), ~ round(.x, 2)))

colnames(plate_Summary) <- c("Plate", "STDPosCtrl", "AvgFociPosCtrl", "CVPosCtrl","NuclearAreaPosCtrl", "NuclearFormFactorPos", "STDNegCtrl", "AvgFociNegCtrl", "CVNegCtrl", "NuclearAreaNegCtrl", "NuclearFormFactorNeg","PlateZScore", "SB")


#Th controls are not showing the correct number of columns.
ctrls <- ctrls %>% 
  mutate(across(where(is.numeric), ~ round(.x, 2)))

colnames(ctrls) <- c("Plate", "Control", "CellCount", "AvgFoci", "NuclearArea", "NuclearFormFactor")

combined_Df <- combined_Df %>% filter( Condition == Well_Num)
  
#For Test Conditions:
if(assayType == "OFF"){
  combined_Df <- combined_Df[, c("BZScore", "Viability", "plate_Num", "Well_Num", "ZPrime_Score", "PercentChange", "Avg_Foci", "CellCountDiff", "Nuclei_Number", "ZScore", "BScore", "NuclearAreaDiff", "NuclearFormFactorDiff",  "AssayType") ]

  colnames(combined_Df) <- c("BZScore", "Viability", "Plate", "Well", "PlateZPrimeScore", "PercentEffect", "AvgFoci", "CellCountPercentDiff", "CellCount", "ZScore", "BScore", "NuclearAreaPercentDiff", "FormFactorPercentDiff", "AssayType")
  
  #Round:
combined_Df <- combined_Df %>% arrange(desc(BZScore)) %>%
  mutate(across(where(is.numeric), ~ round(.x, 2)))

}


if(assayType == "ON"){
  combined_Df <- combined_Df[, c("ZScore", "Viability", "plate_Num", "Well_Num", "ZPrime_Score", "PercentChange", "Avg_Foci", "CellCountDiff", "Nuclei_Number", "NuclearAreaDiff", "NuclearFormFactorDiff",  "AssayType") ]

  colnames(combined_Df) <- c("ZScore", "Viability", "Plate", "Well", "PlateZPrimeScore", "PercentEffect", "AvgFoci", "CellCountPercentDiff", "CellCount",  "NuclearAreaPercentDiff", "FormFactorPercentDiff", "AssayType")
  
  #Round:
  combined_Df <- combined_Df %>% arrange(desc(ZScore)) %>%
  mutate(across(where(is.numeric), ~ round(.x, 2)))

}

#EXPORT DATA:
# Initialize or load Excel workbook
export_File <- paste0(file_Location, "DemoData.xlsx")

# Create a new workbook or load an existing one
wb <- createWorkbook()

# Add sheets
addWorksheet(wb, "Combined Analysis")
addWorksheet(wb, "Plate Statistics")
addWorksheet(wb, "Controls")

# Write data with headers
writeData(wb, "Combined Analysis", combined_Df, startCol = 1, startRow = 1, colNames = TRUE)
#freezePane(wb, sheet = "Combined Analysis", firstActiveRow = 2)

writeData(wb, "Plate Statistics", plate_Summary, startCol = 1, startRow = 1, colNames = TRUE)
freezePane(wb, sheet = "Plate Statistics", firstActiveRow = 2)

writeData(wb, "Controls", ctrls, startCol = 1, startRow = 1, colNames = TRUE)
freezePane(wb, sheet = "Controls", firstActiveRow = 2)

# Save the workbook
saveWorkbook(wb, file = export_File, overwrite = TRUE)

```


```{r}
# ------------- SETUP AND CONFIGURATION -------------
# Disable scientific notation for better readability
options(scipen = 999)

# ============================================================================
# CONDENSCREEN GRAPHICAL PLOT GENERATION 
# ============================================================================


# ------------- DATA LOADING AND PREPARATION -------------
# Load workbook from predefined location (assuming save_Location is defined elsewhere)
wb <- loadWorkbook(export_File)

# Load raw data and exclude plate A19946
merged_df <- read.xlsx(wb, sheet = "Combined Analysis")
#Typically comment the following line out:
merged_df <- merged_df[merged_df$Plate != "A19946", ]

# Convert numeric columns to proper type
merged_df$Average_foci_perCell <- as.numeric(merged_df$AvgFoci)
merged_df$Normalized_Effect <- as.numeric(merged_df$PercentEffect)


#EDIT: Change to location of a file linking compound/gene names to each well, if applicable, else comment out, and run the following #merged_df$Reference <- merged_df$Well
#############################################################
if (assayType == "OFF") {
  template_location <- paste0(file_Location, "DemoMetadata.xlsx")
  template <- read.xlsx(template_location)
  colnames(template) <- c("Plate", "Well", "Reference")

 } else {
  template <- read.xlsx(paste0(file_Location, "DemoMetadata.xlsx"))
  template <- template[, c("Plate.Name", "Plate.Well", "Gene.Symbol")]
  colnames(template) <- c("Plate", "Well", "Reference")


 }

# Merge data with compound names
merged_df <- merge(merged_df, template[, c("Plate", "Well", "Reference")], 
                   by = c("Plate", "Well"), all = TRUE)

#############################################################
#If you do not have access to a file linking reference names to each well, uncomment and run below:

#merged_df$Reference <- merged_df$Well

#############################################################

#-------------------------CHANGE IF NECESSARY----------------------------
# compounds_of_interest <- c("PYRITHIONE ZINC", "CELASTROL", "PLUMBAGIN", "DISULFIRAM")
# genes_of_interest <- c("APOL3", "ZNF335", "RNF26", "RAN", "NUP
#                        50", "EIF4A3", "TOR1A", "TOR1B")
# microcephaly  <- c("ZNF335", "SIN3A", "SPDL1", "CDK5", "NCAPD3", "CIT", "SHH")
#------------------------------------------------------------------------

#############################################################


merged_df <- merged_df[!is.na(merged_df$Reference), ]  # Keep only rows with reference names (compounds, genes, etc.)

# Sort datasets by BZ_Score in descending order

if(assayType == "OFF"){
 merged_df <- merged_df[order(merged_df$BZScore, decreasing = TRUE), ]
}

```

```{r}
#NORMALIZED SCORE PLOT:
#------------------------------------------------------------------------------
plot_normalized_score <- function(df, assay_type, image_path) {
  
  score_col <- if (assay_type == "OFF") sym("BZScore") else sym("ZScore")
  
  label_y <- if (assay_type == "OFF") "BZ-Score" else "Z-Score"
  y_limits <- if (assay_type == "OFF") c(-3, 4) else c(-3, 4)
  y_breaks <- c(  -2, -2, 0, 2, 3,4)
  
  p <- ggplot(df, aes(x = paste0(Well, Plate), y = !!score_col,
                      fill = factor(ifelse(!!score_col >= 2 , "tofill", "nottofill")))) +
    
    # Significant points (>=3)
    geom_point(
      data = filter(df, !!score_col >= 2),
      aes(x = paste0(Well, Plate), y = !!score_col),
      color = "red", size = 2.25
    ) +
    
    # Non-significant points (<3)
    geom_point(
      data = filter(df, !!score_col < 2),
      aes(x = paste0(Well, Plate), y = !!score_col),
      color = "black", size = 1,
      position = position_jitter(width = 0.3, height = 0), alpha = 0.5
    ) +
    
    scale_fill_manual(values = c("tofill" = "red", "nottofill" = "black")) +
    
    theme_classic() +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          axis.text.y = element_text(size = 18, face = "bold"),
          axis.title.y = element_text(size = 24, face = "bold"),
          plot.title = element_text(size = 18),
          axis.title = element_text(size = 24, face = "bold")) +
    
    labs(y = label_y, x = "", title = NULL) +
    
    scale_y_continuous(limits = c(-10, 15), breaks = y_breaks) +
    
    geom_hline(yintercept = 2, color = "#2D0A70", linetype = "dashed", size = 1.75) +
    
    # Label ONLY significant points
    geom_text_repel(
      data = filter(df, !!score_col >= 2),
      aes(label = Reference),
      box.padding = 0.6, size = 5,
      max.overlaps = Inf, fontface = "bold"
    ) +
    
    guides(fill = "none") +
    
    coord_cartesian(ylim = y_limits)
  
  # Save
  ggsave(
    paste0(image_path, "normalized_SigScoreCRISPR.pdf"),
    p, dpi = 300, width = 10, height = 10
  )
  
  print(p)
  return(p)
}


p1 <- plot_normalized_score(merged_df, assayType ,image_Save_Location )

  # Save distribution plots
  ggsave(paste(image_Save_Location, "BZScore_Plot.png", sep = ""), 
        p1, 
        dpi = 300, 
        width = 10, 
        height = 10)
```

```{r}
#DISTRIBUTION PLOTS
#------------------------------------------------------------------------------

#RAW DISTRIBUTION
# Create histogram of raw foci per cell
  raw_distribution <- ggplot(merged_df, aes(x = AvgFoci)) +
    geom_histogram(color = "black", fill = "darkgray", binwidth = 2) +
    geom_density(alpha = 0.6, fill = "black") +
    labs(title = NULL, y = "Count", x = "MLF2-GFP Foci/Cell") +
    theme_classic() +
    theme(title = element_text(size = 40, face = "bold"),
          axis.title.x = element_text(size = 36, face = "bold"),
          axis.text.y = element_text(size = 30, face = "bold"),
          axis.text.x = element_text(size = 30, face = "bold"),
          axis.ticks.length = unit(0.4, "cm"),
          axis.ticks = element_line(size = 1.2))
  

ggsave(paste(image_Save_Location, "RawdistrDemo.png", sep = ""), 
        raw_distribution, 
        dpi = 300, 
        width = 10, 
        height = 10)
  

#NORMALIZED EFFECT DISTRIBUTION
  normalized_dist <- ggplot(merged_df, aes(x = PercentEffect)) +
    geom_histogram(color = "black", fill = "darkgray", binwidth =3.75 ) +
    geom_density(alpha = 0.6, fill = "black") +
    # Add reference lines and labels
    geom_vline(aes(xintercept = 100), linetype = 'dashed', size = 2.5) +
    geom_vline(aes(xintercept = 0), linetype = 'dashed', size = 2.5) +
    theme_classic() +
    theme(title = element_text(size = 40, face = "bold"),
          axis.title.x = element_text(size = 36, face = "bold"),
          axis.text.y = element_text(size = 30, face = "bold"),
          axis.text.x = element_text(size = 30, face = "bold"),
          axis.ticks.length = unit(0.4, "cm"),
          axis.ticks = element_line(size = 1.2))
  
  
#Normalized Distribution Plot:
if (assayType == "OFF") {
normalized_dist <- normalized_dist +
  annotate("text", x = 90, y = 17, label = pos_Ctrl, angle = 90, size = 14) +
  annotate("text", x = -20, y = 17, label = neg_Ctrl, color = "black", angle = 90, size = 14) +
  labs(title = NULL, y = "Count", x = "% Change in Foci")
 } else {
normalized_dist <- normalized_dist +
  annotate("text", x = 90, y = 17, label = pos_Ctrl, angle = 90, size = 14) +
  annotate("text", x = -20, y = 17, label = neg_Ctrl, color = "black", angle = 90, size = 14) +
  labs(title = NULL, y = "Count", x = "% Change in Foci")
 } 
     
  # Save distribution plots
  ggsave(paste(image_Save_Location, "NormalizedDemo.png", sep = ""), 
        normalized_dist, 
        dpi = 300, 
        width = 10, 
        height = 10)
```

```{r}
#Reorder:
#Normalized Distribution Plot:
if (assayType == "OFF") {
merged_df <- merged_df %>% arrange(desc(BZScore))
 } else {
merged_df <- merged_df %>% arrange(desc(ZScore))
 } 
     

# ------------- FINAL DATA EXPORT -------------
  # Save active compounds to Excel

writeData(wb, sheet = "Combined Analysis", x = merged_df, startCol = 1, startRow =  1, colNames = TRUE)
freezePane(wb, sheet = "Combined Analysis", firstActiveRow = 2)

saveWorkbook(wb, export_File, overwrite = TRUE)
```

